package nu.thiele.bachelor.advancedLayouts;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import nu.thiele.bachelor.layouts.MyLayout;
import nu.thiele.bachelor.layouts.RotatedSquare;
import nu.thiele.bachelor.util.AppInfo;
import nu.thiele.bachelor.util.DefaultValues;
import nu.thiele.bachelor.util.Setup;
import android.content.Context;
import android.util.Log;
import android.view.View;
import android.view.ViewGroup;
import android.widget.RelativeLayout;

public class Stack extends MyLayout{
	//true if discrete, false if continuous
	public static boolean DISCRETE_FLIPPING = DefaultValues.STACK_DISCRETE_FLIP;
	public static boolean LINEAR_CONTINUOUS_FLIPPING = DefaultValues.STACK_LINEAR_CONTINUOUS_FLIP;
	public static boolean USE_PREFERRED_ITEMS_IN_LAYOUT = true;
	public static boolean USE_TRANSPARENCY = true;
	
	//When using rotated square, following should be a number generated by: ([x+1]^2+1)/2
	public static int ITEMS_PR_LAYER = 25;
	
	public static final float STACK_ZOOM_LEVEL_TO_NEXT_LAYER = 1.3f; //At what zoom level should the layer go away?
	
	//All the rest
	private float distanceBetweenLayers = 1f; //How much "distance" between layers. Overwritten later
	private float discreteCount = 1.0f;
	private RelativeLayout layout;
	private StackHelper stack;
	public Stack(Context context, List<AppInfo> appInfo) {
		super(context, appInfo);
		this.appInfo = appInfo;
		this.context = context;
		this.stack = new StackHelper(2);
		
		initialize();
	}

	private void calculateLayerOpacity(){
		float minimumOpacity = 0.5f;
		float a = (-minimumOpacity/(Stack.STACK_ZOOM_LEVEL_TO_NEXT_LAYER-1));
		float b = -a+1;
		float opacity = a*this.stack.getTop().getZoomLevel()+b;
		this.stack.getTop().setAlpha(opacity);
	}
	
	@Override
	public ViewGroup getLayout() {
		//If layout is not calculated, do so
		if(this.layout == null){
			//Initialize
			RelativeLayout.LayoutParams fullscreenParams = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_PARENT);
			this.layout = new RelativeLayout(this.context);
			this.layout.setLayoutParams(fullscreenParams);
			
			
			//Add first n layers, in reverse order
			for(int i = this.stack.getShowing().size()-1; i >= 0; i--){
				MyLayout l = this.stack.getShowing().get(i);
				
				//Add the layout to the correct position
				//Only zoom out accordingly on layer to get a dimensional feeling, if 
				float zoom = this.distanceBetweenLayers*i;
				l.setZoom(1-zoom);
				View viewToAdd = l.getLayout();
				this.layout.addView(viewToAdd);
			}
			//Handle opacity
			if(Stack.USE_TRANSPARENCY) this.calculateLayerOpacity();
		}
		return this.layout;
	}
	
	@Override
	public View getViewAt(float x, float y){
		if(this.stack.size() == 0) return null;
		//Look at the top layer and pass call to that
		return this.stack.getTop().getViewAt(x, y);
	}
	
	private void initialize(){
		int i = 0;
		LinkedList<AppInfo> workingAppInfo = new LinkedList<AppInfo>();
		for(AppInfo app : this.appInfo){
			if(i > 0 && i%(Stack.USE_PREFERRED_ITEMS_IN_LAYOUT ? RotatedSquare.getPrefferedItemsInLayout(this.context) : Stack.ITEMS_PR_LAYER) == 0){
				this.stack.addLayer(new RotatedSquare(this.context, workingAppInfo));
				workingAppInfo = new LinkedList<AppInfo>();
			}
			
			//Simply add to the working app info
			workingAppInfo.add(app);
			
			//Remember to increment;
			i++;
		}
		//Add another for the last stack
		MyLayout toAdd = new RotatedSquare(this.context, workingAppInfo);
		if(this.stack.size() > 0) toAdd.ensureItemSize(this.stack.getTop().getItemSize());
		//And add
		this.stack.addLayer(toAdd);
		
		//Calculate all the level's layouts once and for all
		for(MyLayout l : this.stack.getAll()) l.getLayout();
		 
		//Compute the "distance" beteen layers
		//Very simple, since top layer when max zoomed should have the next at scale 100%
		this.distanceBetweenLayers = Stack.STACK_ZOOM_LEVEL_TO_NEXT_LAYER-1;
		
		//Go through all layers and add background color
		for(MyLayout layout : this.stack.getAll()){
			layout.getLayout().setBackgroundColor(Setup.LAYOUT_BACKGROUND_COLOR);
		}		
	}

	@Override
	public boolean moveThroughStack(float howmuch){
		if(this.stack.size() == 0){
			Log.e("Stack", "No layers in stack");
			return false;
		}
		if(this.stack.size() == 1){ //If only one layer, log and do nothing..
			Log.d("Stack", "Only layer on stack");
			return false;
		}
		
		boolean goBackward = false;
		boolean goForward = false;
		
		//If discrete
		if(Stack.DISCRETE_FLIPPING){
			//Update "counter"
			this.discreteCount = this.discreteCount+howmuch;
			
			//Check if need for flip
			if(this.discreteCount >= Stack.STACK_ZOOM_LEVEL_TO_NEXT_LAYER) goForward = true;
			else if(this.discreteCount < Math.abs(2-Stack.STACK_ZOOM_LEVEL_TO_NEXT_LAYER)) goBackward = true;
			
			//If need, do the flip
			if(goForward){
				//Remove old view
				MyLayout viewToRemove = this.stack.getTop();
				this.layout.removeView(viewToRemove.getLayout());
				viewToRemove.reset();
				
				//Find view
				this.stack.moveForward();
				MyLayout v = this.stack.getBottom();

				//And add the layout
				this.layout.addView(v.getLayout(), this.layout.getChildCount()-1);
				
				//Reset "counter"
				this.discreteCount = 1;
			}
			else if(goBackward){
				//Remove old view
				MyLayout viewToRemove = this.stack.getBottom();
				this.layout.removeView(viewToRemove.getLayout());
				viewToRemove.reset();
				
				//Move stack
				this.stack.moveBack();
				
				//View to add
				MyLayout ml = this.stack.getTop();

				//And add to fronts
				this.layout.addView(ml.getLayout());				
				
				//Reset "counter"
				this.discreteCount = 1;
			}
		}
		else{ //Continuous
			//If non-linear movement
			if(!Stack.LINEAR_CONTINUOUS_FLIPPING){
				//Calculate inverse value
				//Convert to correct log-base
				float newbase = (float) 5;
				float x = (float) Math.log((this.stack.getTop().getZoomLevel()-0.99f));
				x = (float) ((x/Math.log(newbase)));//
				//Add and update the "howmuch" parameter
				x = x+howmuch;

				float howmuchtemp = (float) (Math.pow(newbase, x)+0.99);
				howmuch = howmuchtemp-this.stack.getTop().getZoomLevel();
			}
			//Only zoom
			for(MyLayout layout : this.stack.getShowing()){
				layout.zoom(howmuch);
			}
			
			//Get top element. If need for swapping, remember this
			if(this.stack.getTop().getZoomLevel() >= Stack.STACK_ZOOM_LEVEL_TO_NEXT_LAYER) goForward = true;
			else if(this.stack.getTop().getZoomLevel() < 1) goBackward = true;
			
			if(goForward){
				//Remove old view
				MyLayout toRemove = this.stack.getTop();
				this.layout.removeView(toRemove.getLayout());
				//Reset old view after removing
				toRemove.reset();
				
				//Find new view
				this.stack.moveForward();
				MyLayout v = this.stack.getBottom();

				//Zoom
				v.setZoom(1-this.distanceBetweenLayers);
				//And add the layout
				this.layout.addView(v.getLayout(), this.layout.getChildCount()-1);
				//Ensure size of top layers. Because of some
				//precision issue with floats, this will slowly
				//screw up otherwise
				this.stack.getTop().setZoom(1.0f);
			}
			else if(goBackward){
				//Remove old view, reset everything
				MyLayout toRemove = this.stack.getBottom();
				this.layout.removeView(toRemove.getLayout());
				toRemove.reset();
				
				//Move stack
				this.stack.moveBack();
				
				//View to add
				MyLayout ml = this.stack.getTop();
				//Set correct zoom. Should be: full+"distance"
				ml.setZoom(1+this.distanceBetweenLayers);
				//And add to front
				this.layout.addView(ml.getLayout());			
			}
			
			//And calculate new opacities
			if(Stack.USE_TRANSPARENCY) this.calculateLayerOpacity();
		}
		
		return true;
	}
	
	@Override
	public void reset(){
		//If discrete flipping
		if(Stack.DISCRETE_FLIPPING){
			//Reset all stack layers
			for(MyLayout l : this.stack.getAll()) l.reset();
		}
		else{
			//Reset all stack layers
			for(MyLayout l : this.stack.getAll()) l.reset();
			
			//Set zoom levels
			for(int i = 0; i < this.stack.getShowing().size(); i++){
				this.stack.getShowing().get(i).setZoom(1-i*this.distanceBetweenLayers);
			}
		}
	}
	
	/**
	 * To help me do the dirty work
	 * @author Andreas
	 *
	 */
	private class StackHelper{		
		private ArrayList<MyLayout> layers;
		private int top, bottom;
		
		/**
		 * 
		 * @param number Number of layers to keep visible on stack
		 */
		public StackHelper(int number){
			this.layers = new ArrayList<MyLayout>();
			this.top = 0;
			this.bottom = number-1; //Input will be 1-indexed, so make it 0
		}
		
		public void addLayer(MyLayout l){
			//Make sure the layer has been computed
			l.getLayout();
			
			//And add
			this.layers.add(l);
		}
		
		public MyLayout get(int w){
			return this.layers.get(w);
		}
		
		public ArrayList<MyLayout> getAll(){
			return this.layers;
		}
		
		public MyLayout getBottom(){
			return this.get(this.bottom);
		}
		
		public MyLayout getFirst(){
			return this.layers.get(0);
		}
		
		public MyLayout getNext(){
			return this.get((this.top+1)%this.layers.size());
		}
		
		public ArrayList<MyLayout> getShowing(){
			ArrayList<MyLayout> retval = new ArrayList<MyLayout>();
			for(int i = top; true; i = (i+1)%this.layers.size()){
				retval.add(this.layers.get(i));
				if(i == bottom) break;
			}
			return retval;
		}
		
		public MyLayout getTop(){
			return this.layers.get(this.top);
		}
		
		public void moveBack(){
			this.bottom--;
			this.top--;
			if(this.bottom < 0) this.bottom = this.layers.size()-1;
			if(this.top < 0) this.top = this.layers.size()-1;
		}
		
		public void moveForward(){
			this.bottom = (this.bottom+1)%this.layers.size();
			this.top = (this.top+1)%this.layers.size();
		}
		
		public int size(){
			return this.layers.size();
		}
	}

	@Override
	public void ensureItemSize(int size) {
		//This should not do anything
	}
}
